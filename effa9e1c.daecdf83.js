(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{194:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return o})),r.d(t,"metadata",(function(){return s})),r.d(t,"rightToc",(function(){return l})),r.d(t,"default",(function(){return p}));var a=r(2),n=r(9),i=(r(0),r(198)),o={id:"why-use-replication",title:"Why use Replication?"},s={id:"postgresql/20-postgresql-theory/why-use-replication",isDocsHomePage:!1,title:"Why use Replication?",description:"In previous chapters of the Kubernetes training a StatefulSet has been developed.",source:"@site/docs/postgresql/20-postgresql-theory/02-why-replication.md",permalink:"/postgresql/20-postgresql-theory/why-use-replication",sidebar:"docs",previous:{title:"Overview",permalink:"/postgresql/postgresql-overview"},next:{title:"Replication Outline",permalink:"/postgresql/20-postgresql-theory/replication-outline"}},l=[{value:"Limitations of the Previously Created PostgreSQL StatefulSet",id:"limitations-of-the-previously-created-postgresql-statefulset",children:[]},{value:"Why Replicate at all?",id:"why-replicate-at-all",children:[]},{value:"Summary",id:"summary",children:[]}],c={rightToc:l};function p(e){var t=e.components,r=Object(n.a)(e,["components"]);return Object(i.b)("wrapper",Object(a.a)({},c,r,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"In previous chapters of the Kubernetes training a StatefulSet has been developed."),Object(i.b)("h2",{id:"limitations-of-the-previously-created-postgresql-statefulset"},"Limitations of the Previously Created PostgreSQL StatefulSet"),Object(i.b)("p",null,"This PostgreSQL StatefuSet can provide a single PostgreSQL Pod meaningfully. The single PostgreSQL pod is meaningful as it can be used to store data and can be accessed by application. While it is possible to set the number of ",Object(i.b)("inlineCode",{parentName:"p"},"replicas")," to more then ",Object(i.b)("inlineCode",{parentName:"p"},"1")," this doesn't make sense as there is not replication among the pods of the StatefulSet. Having ",Object(i.b)("inlineCode",{parentName:"p"},"3")," unrelated PostgreSQL servers doesn't really provide any benefit."),Object(i.b)("p",null,"This leads to two questions:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"Why replicate at all?"),Object(i.b)("li",{parentName:"ol"},"How can replication be configured?")),Object(i.b)("h2",{id:"why-replicate-at-all"},"Why Replicate at all?"),Object(i.b)("p",null,"Experienced database adminstrators may find this question disturbing as a highly available database seem to be impossible without replication. However, there is more to this question than meets the eye."),Object(i.b)("p",null,"Experience shows that in a physical server setup, a failed PostgreSQL has a certain average time to repair (TTR). If hardware needs to be replaced, for example, this may take up to several hours - without the necessary spare parts - even days or weeks. Having a standby-server to failover to is therefore crucial. This will reduce the TTR down to minutes or even seconds."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"With virtual machines on a contemporary infrastructure a separation of the ephemeral VM and it's persistent disk has become standard"),". With this architectural pattern, the data of a database isn't stored on the local disk of a infrastructure host but on a highly available, remotely attached block device. This so called ",Object(i.b)("em",{parentName:"p"},"persistent disk")," or ",Object(i.b)("em",{parentName:"p"},"persistent volume")," separates the lifecycle of the (PostgreSQL) VM from the lifecycle of its (PostgreSQL) data."),Object(i.b)("p",null,"In case of a failed VM, there is no need to wait for hardware to be fixed. With the proper automation, the VM will be rescheduled on a different infrastructure host and the persistent disk will be attached. ",Object(i.b)("strong",{parentName:"p"},"The time to repair for such a self-healing scenario lies within several minutes"),"."),Object(i.b)("p",null,"The motivation to tackle the complexity of replication and cluster management already decreases as the TTR has been drastically reduced by the self-healing automation."),Object(i.b)("p",null,"With Kubernetes and containers this time to repair may shrink even further. Assuming that involved container images are relatively small and/or cached on the Kubernetes nodes, ",Object(i.b)("strong",{parentName:"p"},"the self-healing of a failed Pod instead of a failed VM is a matter of seconds rather than minutes"),"."),Object(i.b)("p",null,"However, this is an oversimplification as ",Object(i.b)("strong",{parentName:"p"},"the time to repair may dramatically change")," if the failure isn't caused by the failure of a single infrastructure host but of the ",Object(i.b)("strong",{parentName:"p"},"failure of an entire infrastructure availability zone")," or if the ",Object(i.b)("strong",{parentName:"p"},"storage server containing the persistent disk has failed"),"."),Object(i.b)("p",null,"In these cases a recovery from a backup may be necessary which implies a corresponding ",Object(i.b)("strong",{parentName:"p"},"data loss"),"."),Object(i.b)("h2",{id:"summary"},"Summary"),Object(i.b)("p",null,"In order to allow a fast failover and reduce to the potential data loss to a minum, ",Object(i.b)("strong",{parentName:"p"},"replication can be used to keep spare standby servers across availability zones"),". For most infrastructures, this also implies using disjunct storage servers."))}p.isMDXComponent=!0},198:function(e,t,r){"use strict";r.d(t,"a",(function(){return u})),r.d(t,"b",(function(){return b}));var a=r(0),n=r.n(a);function i(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){i(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var c=n.a.createContext({}),p=function(e){var t=n.a.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},u=function(e){var t=p(e.components);return n.a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.a.createElement(n.a.Fragment,{},t)}},d=n.a.forwardRef((function(e,t){var r=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=p(r),d=a,b=u["".concat(o,".").concat(d)]||u[d]||h[d]||i;return r?n.a.createElement(b,s(s({ref:t},c),{},{components:r})):n.a.createElement(b,s({ref:t},c))}));function b(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=r.length,o=new Array(i);o[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=r[c];return n.a.createElement.apply(null,o)}return n.a.createElement.apply(null,r)}d.displayName="MDXCreateElement"}}]);
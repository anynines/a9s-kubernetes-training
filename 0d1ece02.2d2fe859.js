(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{147:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return d}));var s=n(0),a=n.n(s);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,s,a=function(e,t){if(null==e)return{};var n,s,a={},r=Object.keys(e);for(s=0;s<r.length;s++)n=r[s],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(s=0;s<r.length;s++)n=r[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),p=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i({},t,{},e)),n},b=function(e){var t=p(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},h=Object(s.forwardRef)((function(e,t){var n=e.components,s=e.mdxType,r=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),b=p(n),h=s,d=b["".concat(l,".").concat(h)]||b[h]||u[h]||r;return n?a.a.createElement(d,i({ref:t},c,{components:n})):a.a.createElement(d,i({ref:t},c))}));function d(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=n.length,l=new Array(r);l[0]=h;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:s,l[1]=i;for(var c=2;c<r;c++)l[c]=n[c];return a.a.createElement.apply(null,l)}return a.a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},99:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return o})),n.d(t,"default",(function(){return p}));var s=n(1),a=n(6),r=(n(0),n(147)),l={id:"stateful-set-headless-service",title:"Headless Service"},i={id:"kubernetes/80-stateful-sets/stateful-set-headless-service",title:"Headless Service",description:"Once you have create the PostgreSQL StatefulSet you may want to access it with an application. The next lessons will therefore evolve towards application access, step by step.",source:"@site/docs/kubernetes/80-stateful-sets/35-postgresql-headless-service-exercise.md",permalink:"/kubernetes/80-stateful-sets/stateful-set-headless-service",sidebar:"docs",previous:{title:"PostgreSQL StatefulSet",permalink:"/kubernetes/80-stateful-sets/stateful-set-postgresql"},next:{title:"StatefulSet vs. ReplicaSets",permalink:"/kubernetes/80-stateful-sets/stateful-set-vs-replicasets"}},o=[{value:"The StatefulSet and its Headless Service",id:"the-statefulset-and-its-headless-service",children:[]},{value:"Headless Service for StatefulSets with Mulitple Replicas",id:"headless-service-for-statefulsets-with-mulitple-replicas",children:[]},{value:"Links",id:"links",children:[]}],c={rightToc:o};function p(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(s.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Once you have create the PostgreSQL StatefulSet you may want to access it with an application. The next lessons will therefore evolve towards application access, step by step."),Object(r.b)("h2",{id:"the-statefulset-and-its-headless-service"},"The StatefulSet and its Headless Service"),Object(r.b)("p",null,"In the previous chapter you have learned that a StatefulSet has a stable network identity. As mentioned before, the PostgreSQL StatefulSet will be accessed by an application. As applications may change during version updates or being rescheduled in the Cluster, so could be Pods of a StatefulSet. With both the application Deployments and the StatefulSet being fast moving targets, it is the StatefulSet's headless Service providing a stable entry point for the application to reach out to the PostgreSQL StatefulSet."),Object(r.b)("p",null,"Have a look at what you have created in the previous lesson:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl describe service postgresql-svc\n")),Object(r.b)("p",null,"Shows that the headless Service ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-svc")," has the label ",Object(r.b)("inlineCode",{parentName:"p"},"Labels: app=postgresql-a"),"."),Object(r.b)("p",null,"And:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl describe service postgresql-svc\n")),Object(r.b)("p",null,"Produces an output similar to:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"Name:              postgresql-svc\nNamespace:         k8s-training\nLabels:            app=postgresql-a\nAnnotations:       Selector:  app=postgresql-a\nType:              ClusterIP\nIP:                None\nPort:              postgresql-port  5432/TCP\nTargetPort:        5432/TCP\nEndpoints:         172.17.0.5:5432\nSession Affinity:  None\nEvents:            <none>\n")),Object(r.b)("p",null,"Which shows ",Object(r.b)("inlineCode",{parentName:"p"},"Annotations: Selector:  app=postgresql-a")," indicating that the Service is connected to the StatefulSet through the Label ",Object(r.b)("inlineCode",{parentName:"p"},"app=postgresql-a"),". You can see that in the ",Object(r.b)("inlineCode",{parentName:"p"},"Endpoints: 172.17.0.5:5432")," line which refers to the Pod ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-sfs-0")," of the StatefulSet ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-sfs"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl describe pod kubectl describe postgresql-sfs-0\n")),Object(r.b)("p",null,"The output shows that the Pod ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-sfs-0")," has the ",Object(r.b)("inlineCode",{parentName:"p"},"IP: 172.17.0.5")," which means that the Pod is set as the endpoint of the headless Service."),Object(r.b)("p",null,"This means that a DNS entry will be created pointing directly to the the Pods associated with the Service."),Object(r.b)("p",null,"Verify this by executing:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl describe service postgresql-svc\n")),Object(r.b)("p",null,"Which reveals that the headless Service ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-svc")," has the label ",Object(r.b)("inlineCode",{parentName:"p"},"Labels: app=postgresql-a"),"."),Object(r.b)("p",null,"And:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl describe service postgresql-svc\n")),Object(r.b)("p",null,"Produces an output similar to:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"Name:              postgresql-svc\nNamespace:         k8s-training\nLabels:            app=postgresql-a\nAnnotations:       Selector:  app=postgresql-a\nType:              ClusterIP\nIP:                None\nPort:              postgresql-port  5432/TCP\nTargetPort:        5432/TCP\nEndpoints:         172.17.0.5:5432\nSession Affinity:  None\nEvents:            <none>\n")),Object(r.b)("p",null,"This shows ",Object(r.b)("inlineCode",{parentName:"p"},"Annotations: Selector:  app=postgresql-a")," indicating that the Service is connected to the StatefulSet through the Label ",Object(r.b)("inlineCode",{parentName:"p"},"app=postgresql-a"),". You can see that in the ",Object(r.b)("inlineCode",{parentName:"p"},"Endpoints: 172.17.0.5:5432")," line which refers to the Pod ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-sfs-0")," of the StatefulSet ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-sfs"),"."),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl describe pod kubectl describe postgresql-sfs-0\n")),Object(r.b)("p",null,"The output shows that the Pod ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-sfs-0")," has the ",Object(r.b)("inlineCode",{parentName:"p"},"IP: 172.17.0.5")," which means that the Pod is set as the endpoint of the headless Service."),Object(r.b)("p",null,"Along with the headless Service ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-svc")," Kubernetes will create a cluster-internal DNS entry: ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-svc.k8s-training.svc.cluster.local"),". "),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Go and see yourself!")),Object(r.b)("p",null,"First, get inside the cluster by launching a utility Pod:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl run -i --tty nspct --image=fischerjulian/nspct --restart=Never -- bash\n")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"nspct")," image provides a few handy tools such as ",Object(r.b)("inlineCode",{parentName:"p"},"nslookup")," - a utility to query nameservers."),Object(r.b)("p",null,"Inside of the ",Object(r.b)("inlineCode",{parentName:"p"},"nspct")," Pod check wether the resolver can resolve the service url:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"nslookup postgresql-svc.k8s-training.svc.cluster.local\n")),Object(r.b)("p",null,"Which will produce a response similar to:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"Server:     10.96.0.10\nAddress:    10.96.0.10#53\n\nName:    postgresql-svc.k8s-training.svc.cluster.local\nAddress: 172.17.0.5\n")),Object(r.b)("p",null,"So the DNS entry has been created and resolves to the IP address of the only Pod inside of the StatefulSet. "),Object(r.b)("p",null,"Hence, the headless Service provides a stable network identity for the StatefulSet as the Service couples to the StatefulSet loosely by using a selector in the Service referring to the label ",Object(r.b)("inlineCode",{parentName:"p"},"app=postgresql-a")," in the StatefulSet."),Object(r.b)("h2",{id:"headless-service-for-statefulsets-with-mulitple-replicas"},"Headless Service for StatefulSets with Mulitple Replicas"),Object(r.b)("p",null,"With a single Pod (",Object(r.b)("inlineCode",{parentName:"p"},"replicas: 1"),") in a StatefulSet the mapping from the headless Service to the Pod is unambiguous: ",Object(r.b)("inlineCode",{parentName:"p"},"service -> Pod"),". "),Object(r.b)("p",null,"This raises the question ",Object(r.b)("strong",{parentName:"p"},"what happens if there are mulitple Pods in the StatefulSet?")),Object(r.b)("p",null,"Let's try it!"),Object(r.b)("p",null,"First, we need a Statefulset with mulitple replicas. So we modify the StatefulSet definition of the previous example by ",Object(r.b)("strong",{parentName:"p"},"editing")," the file ",Object(r.b)("inlineCode",{parentName:"p"},"30-stateful-set.yaml"),"."),Object(r.b)("p",null,"Within ",Object(r.b)("inlineCode",{parentName:"p"},"30-stateful-set.yaml")," change ",Object(r.b)("inlineCode",{parentName:"p"},"replicas: 1")," to ",Object(r.b)("inlineCode",{parentName:"p"},"replicas: 3"),". Save the file and apply it:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl apply -f 30-stateful-set.yaml\n")),Object(r.b)("p",null,"This will update the existing StatefulSet ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-sfs")," and you should see the number of Pods increase from 1 to 3:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl get statefulsets\n")),Object(r.b)("p",null,"Of course, ",Object(r.b)("strong",{parentName:"p"},"this StatefulSet does not consitute a functioning PostgreSQL cluster")," but that's alright. All that matters here is the number of Pods to see show the relationship between the number of replicas and the headless Service."),Object(r.b)("p",null,"Now check on the Service again:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl describe service postgresql-svc\n")),Object(r.b)("p",null,"Which should produce an output similar to:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"Name:              postgresql-svc\nNamespace:         k8s-training\nLabels:            app=postgresql-a\nAnnotations:       Selector:  app=postgresql-a\nType:              ClusterIP\nIP:                None\nPort:              postgresql-port  5432/TCP\nTargetPort:        5432/TCP\nEndpoints:         172.17.0.5:5432,172.17.0.7:5432,172.17.0.8:5432\nSession Affinity:  None\nEvents:            <none>\n")),Object(r.b)("p",null,"Pay attention how the ",Object(r.b)("inlineCode",{parentName:"p"},"Endpoints")," attribute of the Service has changed without touching the Service explicitly. It now has 3 instead of endpoint: ",Object(r.b)("inlineCode",{parentName:"p"},"172.17.0.5:5432,172.17.0.7:5432,172.17.0.8:5432"),"."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"So what does the existence of two additional endpoints imply for the DNS configuration"),"? It means that now the mapping from the Service ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql-svc")," ambiguous. It's not a 1:1 but a 1:3 mapping. So let's figure out what this means by running another utility Pod:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"kubectl run -i --tty nspct --image=fischerjulian/nspct --restart=Never -- bash\n")),Object(r.b)("p",null,"Within the utility Pod perform another domain lookup:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"nslookup postgresql-svc.k8s-training.svc.cluster.local\n")),Object(r.b)("p",null,"Which this time will produce:"),Object(r.b)("pre",null,Object(r.b)("code",Object(s.a)({parentName:"pre"},{}),"Server:     10.96.0.10\nAddress:    10.96.0.10#53\n\nName:   postgresql-svc.k8s-training.svc.cluster.local\nAddress: 172.17.0.7\nName:   postgresql-svc.k8s-training.svc.cluster.local\nAddress: 172.17.0.5\nName:   postgresql-svc.k8s-training.svc.cluster.local\nAddress: 172.17.0.8\n")),Object(r.b)("p",null,"As you can see all StatefulSet Pods are present in the response."),Object(r.b)("h2",{id:"links"},"Links"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"PostgreSQL Docker Image at DockerHub, ",Object(r.b)("a",Object(s.a)({parentName:"li"},{href:"https://hub.docker.com/_/postgres"}),"https://hub.docker.com/_/postgres")),Object(r.b)("li",{parentName:"ol"},"Kubernetes Examples on GitHub, Persistent Volume Provisioning, ",Object(r.b)("a",Object(s.a)({parentName:"li"},{href:"https://github.com/kubernetes/examples/blob/master/staging/persistent-volume-provisioning/README.md"}),"https://github.com/kubernetes/examples/blob/master/staging/persistent-volume-provisioning/README.md")),Object(r.b)("li",{parentName:"ol"},"PostgreSQL Documentation - psql, ",Object(r.b)("a",Object(s.a)({parentName:"li"},{href:"https://www.postgresql.org/docs/12/app-psql.html"}),"https://www.postgresql.org/docs/12/app-psql.html")),Object(r.b)("li",{parentName:"ol"},"Kelsey Hightower @ Twitter, ",Object(r.b)("a",Object(s.a)({parentName:"li"},{href:"https://twitter.com/kelseyhightower/status/935252923721793536?lang=en"}),"https://twitter.com/kelseyhightower/status/935252923721793536?lang=en")),Object(r.b)("li",{parentName:"ol"},"Cloud Foundry, ",Object(r.b)("a",Object(s.a)({parentName:"li"},{href:"https://www.cloudfoundry.org/"}),"https://www.cloudfoundry.org/")),Object(r.b)("li",{parentName:"ol"},"Open Service Broker API, ",Object(r.b)("a",Object(s.a)({parentName:"li"},{href:"https://www.openservicebrokerapi.org/"}),"https://www.openservicebrokerapi.org/")),Object(r.b)("li",{parentName:"ol"},"anynines, a9s Data Services, ",Object(r.b)("a",Object(s.a)({parentName:"li"},{href:"https://www.anynines.com/data-services"}),"https://www.anynines.com/data-services")),Object(r.b)("li",{parentName:"ol"},"Kubernetes Documentation, Concepts, ServiceCatalog, ",Object(r.b)("a",Object(s.a)({parentName:"li"},{href:"https://kubernetes.io/docs/concepts/extend-kubernetes/service-catalog/"}),"https://kubernetes.io/docs/concepts/extend-kubernetes/service-catalog/")),Object(r.b)("li",{parentName:"ol"},"Wikipedia, Principle of Least Privilege, ",Object(r.b)("a",Object(s.a)({parentName:"li"},{href:"https://en.wikipedia.org/wiki/Principle_of_least_privilege"}),"https://en.wikipedia.org/wiki/Principle_of_least_privilege"))))}p.isMDXComponent=!0}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{186:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return l})),n.d(t,"metadata",(function(){return o})),n.d(t,"rightToc",(function(){return i})),n.d(t,"default",(function(){return p}));var a=n(2),s=n(9),r=(n(0),n(198)),l={id:"stateful-sets-revisited",title:"StatefulSets Revisited"},o={id:"postgresql/30-stateful-sets-revisited/stateful-sets-revisited",isDocsHomePage:!1,title:"StatefulSets Revisited",description:"Equipped with a understanding of how PostgreSQL streaming replication works and how it is set up, the next step is to think about its automation. As a preliminary step - to sharpen the knives so to say - a closer look at the behavior of StatefulSets will help to find solutions to upcoming automation challenges quicker.",source:"@site/docs/postgresql/30-stateful-sets-revisited/10-stateful-sets-revisited.md",permalink:"/postgresql/30-stateful-sets-revisited/stateful-sets-revisited",sidebar:"docs",previous:{title:"Setting up Streaming Replication",permalink:"/postgresql/20-postgresql-theory/setting-up-streaming-replication"},next:{title:"Service to Connnect to the Primary",permalink:"/postgresql/40-building-the-pg-stateful-set/pg-service-primary"}},i=[{value:"A StatefulSet with Mulitple Replicas",id:"a-statefulset-with-mulitple-replicas",children:[{value:"The Default is Replicas: 3",id:"the-default-is-replicas-3",children:[]}]},{value:"Creating a PostgreSQL StatefulSet with 3 Replicas",id:"creating-a-postgresql-statefulset-with-3-replicas",children:[]},{value:"Cluster Connectivity",id:"cluster-connectivity",children:[]},{value:"Summary",id:"summary",children:[]}],c={rightToc:i};function p(e){var t=e.components,n=Object(s.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Equipped with a understanding of how PostgreSQL streaming replication works and how it is set up, the next step is to think about its automation. As a preliminary step - to sharpen the knives so to say - a closer look at the behavior of StatefulSets will help to find solutions to upcoming automation challenges quicker."),Object(r.b)("p",null,"Note: This chapter connects to the ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"/kubernetes/80-stateful-sets/stateful-sets"}),"StatefulSet chapters")," of the Kubernetes tutorial. ",Object(r.b)("strong",{parentName:"p"},"So in case you have deleted these resources go back and re-create the final PostgreSQL StatefulSet presented there in the ",Object(r.b)("inlineCode",{parentName:"strong"},"pg")," namespace.")),Object(r.b)("h2",{id:"a-statefulset-with-mulitple-replicas"},"A StatefulSet with Mulitple Replicas"),Object(r.b)("p",null,"A highgly available PostgreSQL cluster should have ",Object(r.b)("inlineCode",{parentName:"p"},"2n+1 | n>= 1")," Pods. These Pods have to discover another as they need to establish network connections as part of the replication and cluster management communication."),Object(r.b)("h3",{id:"the-default-is-replicas-3"},"The Default is Replicas: 3"),Object(r.b)("p",null,"Throughout the remainder of this tutorial the default will be ",Object(r.b)("inlineCode",{parentName:"p"},"replicas: 3")," as the transition from ",Object(r.b)("inlineCode",{parentName:"p"},"replicas: 1")," to ",Object(r.b)("inlineCode",{parentName:"p"},"replicas: 3")," implies all challenges and subsequent scale-outs to ",Object(r.b)("inlineCode",{parentName:"p"},"n>=2")," such as ",Object(r.b)("inlineCode",{parentName:"p"},"replicas: 5")," will be much easier to handle."),Object(r.b)("h2",{id:"creating-a-postgresql-statefulset-with-3-replicas"},"Creating a PostgreSQL StatefulSet with 3 Replicas"),Object(r.b)("p",null,"As a first step create a file ",Object(r.b)("inlineCode",{parentName:"p"},"10-statefulset.yaml"),":"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-yaml"}),'apiVersion: apps/v1\nkind: StatefulSet\nmetadata:\n  name: postgresql-sfs\nspec:\n  selector:\n    matchLabels:\n      app: postgresql-a # has to match .spec.template.metadata.labels\n  serviceName: "postgresql-svc"\n  replicas: 3 # by default is 1\n  template:\n    metadata:\n      labels:\n        app: postgresql-a # has to match .spec.selector.matchLabels\n    spec:\n      terminationGracePeriodSeconds: 10\n      containers:\n      - name: postgresql-db\n        image: postgres:12.2\n        env:\n        - name: POSTGRES_PASSWORD\n          valueFrom:\n            secretKeyRef:\n              name: postgresql-secrets\n              key: POSTGRES_PASSWORD\n        - name: PGDATA\n          value: /var/lib/postgresql/data/pgdata\n        ports:\n        - containerPort: 5432\n          name: postgresql-port\n        volumeMounts:\n        - name: data\n          mountPath: /var/lib/postgresql/data\n  volumeClaimTemplates:\n  - metadata:\n      name: data\n    spec:\n      accessModes: [ "ReadWriteOnce" ]\n      storageClassName: "default"\n      resources:\n        requests:\n          storage: 1Gi\n')),Object(r.b)("p",null,"Apply it:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"kubectl apply -f `10-statefulset.yaml`\n")),Object(r.b)("p",null,"You should now see a StatefulSet with three Pods:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"kubectl get pods\n")),Object(r.b)("p",null,"Output:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"NAME                     READY   STATUS    RESTARTS   AGE\n[...]\npostgresql-sfs-0         1/1     Running   0          45m\npostgresql-sfs-1         1/1     Running   0          45m\npostgresql-sfs-2         1/1     Running   0          45m\n")),Object(r.b)("p",null,"There should also be the corresponding headless Service:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"kubectl get service postgresql-svc\n")),Object(r.b)("p",null,"Output:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"NAME             TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE\npostgresql-svc   ClusterIP   None         <none>        5432/TCP   5h55m\n")),Object(r.b)("h2",{id:"cluster-connectivity"},"Cluster Connectivity"),Object(r.b)("p",null,"As stated earlier, in order to build a replicating PostgreSQL cluster, the individual cluster nodes must be able to communicate with eachother. "),Object(r.b)("p",null,"A first thought could be to create three headless Services, one for each member of the 3-replica StatefulSet but in fact this isn't necessary. Kubernetes will automatically propagate ",Object(r.b)("inlineCode",{parentName:"p"},"SRV")," records ","[1]"," in its DNS system ","[2]",". Go and see yourself:"),Object(r.b)("p",null,"Start a utility Pod:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"kubectl run -i --tty nspct --image=fischerjulian/nspct --restart=Never -- bash\n")),Object(r.b)("p",null,"As you already know you can lookup the Pod IP addresses of the StatefulSet using a DNS query such as:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"nslookup postgresql-svc.pg.svc.cluster.local\n")),Object(r.b)("p",null,"Output:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"Server:     10.96.0.10\nAddress:    10.96.0.10#53\n\nName:   postgresql-svc.pg.svc.cluster.local\nAddress: 172.17.0.13\nName:   postgresql-svc.pg.svc.cluster.local\nAddress: 172.17.0.14\nName:   postgresql-svc.pg.svc.cluster.local\nAddress: 172.17.0.10\n")),Object(r.b)("p",null,"Remember that the headless Service uses DNS entries exclusively and does not perform a layer-4 load balancing."),Object(r.b)("p",null,"When boostrapping the Pods of the PostgreSQL we will need more control than this as we need to reach out to each Pod by its role or even its name. Reaching to a particular node in the StatefulSet is simple as shown in the following."),Object(r.b)("p",null,"Within the utility Pod ",Object(r.b)("inlineCode",{parentName:"p"},"nspct")," execute:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"host -t SRV postgresql-svc.pg.svc.cluster.local\n")),Object(r.b)("p",null,"Output: "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"postgresql-svc.pg.svc.cluster.local has SRV record 0 33 5432 postgresql-sfs-0.postgresql-svc.pg.svc.cluster.local.\npostgresql-svc.pg.svc.cluster.local has SRV record 0 33 5432 postgresql-sfs-1.postgresql-svc.pg.svc.cluster.local.\npostgresql-svc.pg.svc.cluster.local has SRV record 0 33 5432 postgresql-sfs-2.postgresql-svc.pg.svc.cluster.local.\n")),Object(r.b)("p",null,"This means that each Pod of the StatefulSet has a stable unique network identifier depending on the name of the headless Service as well as the namespace:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"postgresql-sfs-0.postgresql-svc.pg.svc.cluster.local")," -> Pod 0"),Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"postgresql-sfs-1.postgresql-svc.pg.svc.cluster.local")," -> Pod 1"),Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"postgresql-sfs-2.postgresql-svc.pg.svc.cluster.local")," -> Pod 2")),Object(r.b)("p",null,"Knowing that each node runs a PostgreSQL on port ",Object(r.b)("inlineCode",{parentName:"p"},"5432")," this means that ",Object(r.b)("strong",{parentName:"p"},"you can connect to each Pod's PostgreSQL using a reliable and predictable URL"),", here using ",Object(r.b)("inlineCode",{parentName:"p"},"telnet")," in the ",Object(r.b)("inlineCode",{parentName:"p"},"nspct")," Pod:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"kubectl run -i --tty nspct --image=fischerjulian/nspct --restart=Never -- bash\n")),Object(r.b)("p",null,"And within the ",Object(r.b)("inlineCode",{parentName:"p"},"nspct")," Pod:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"telnet postgresql-sfs-0.postgresql-svc.pg.svc.cluster.local 5432\n")),Object(r.b)("p",null,"Output:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"Connected to postgresql-sfs-0.postgresql-svc.pg.svc.cluster.local.\nEscape character is '^]'\n")),Object(r.b)("p",null,"Hence, ",Object(r.b)("strong",{parentName:"p"},"it is also possible to reach out from one StatefulSet Pod to another Pod using these SRV records"),"."),Object(r.b)("p",null,"Another important fact about the headless Service is that it will reflect upon changes of the underlying Pods. In case a Pod fails and has to be rescheduled the headless Service will resolve to the new Pod's IP address within seconds. This will allow self-healing of Pods to occur without the need for configuration file updates such as the ",Object(r.b)("inlineCode",{parentName:"p"},"pg_hba.conf")," for authentication or the ",Object(r.b)("inlineCode",{parentName:"p"},"postgresql.conf")," to update the ",Object(r.b)("inlineCode",{parentName:"p"},"primary_conninfo")," attribute."),Object(r.b)("h2",{id:"summary"},"Summary"),Object(r.b)("p",null,"The experiments with the StatefulSet show that the combination with a headless Service provide a stable network identity required for the automation of a PostgreSQL stream replication cluster. The headless Service provides an endpoint that resolves to all Pods of the StatefulSet but also provides endpoints to reach out to specific Pods while being up to date with underlying Pod changes. This is very promising but we have to keep in eye on the timing as propagating DNS entries may take a few seconds. Hence, race conditions may occur during the Pod startup between the assumption about the presence of DNS entry and its actual manifestation."),Object(r.b)("h1",{id:"links"},"Links"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Wikipedia, SRV Record, ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://en.wikipedia.org/wiki/SRV_record"}),"https://en.wikipedia.org/wiki/SRV_record")),Object(r.b)("li",{parentName:"ol"},"Kubernetes Documentation, Tutorials, StatefulSet Basics, ",Object(r.b)("a",Object(a.a)({parentName:"li"},{href:"https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/"}),"https://kubernetes.io/docs/tutorials/stateful-application/basic-stateful-set/"))))}p.isMDXComponent=!0},198:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return h}));var a=n(0),s=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var c=s.a.createContext({}),p=function(e){var t=s.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=p(e.components);return s.a.createElement(c.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},d=s.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,l=e.parentName,c=i(e,["components","mdxType","originalType","parentName"]),u=p(n),d=a,h=u["".concat(l,".").concat(d)]||u[d]||b[d]||r;return n?s.a.createElement(h,o(o({ref:t},c),{},{components:n})):s.a.createElement(h,o({ref:t},c))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=d;var o={};for(var i in t)hasOwnProperty.call(t,i)&&(o[i]=t[i]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var c=2;c<r;c++)l[c]=n[c];return s.a.createElement.apply(null,l)}return s.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"}}]);
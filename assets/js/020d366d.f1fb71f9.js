"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4190],{3905:function(e,t,s){s.d(t,{Zo:function(){return m},kt:function(){return h}});var a=s(7294);function o(e,t,s){return t in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}function n(e,t){var s=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),s.push.apply(s,a)}return s}function r(e){for(var t=1;t<arguments.length;t++){var s=null!=arguments[t]?arguments[t]:{};t%2?n(Object(s),!0).forEach((function(t){o(e,t,s[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(s)):n(Object(s)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(s,t))}))}return e}function i(e,t){if(null==e)return{};var s,a,o=function(e,t){if(null==e)return{};var s,a,o={},n=Object.keys(e);for(a=0;a<n.length;a++)s=n[a],t.indexOf(s)>=0||(o[s]=e[s]);return o}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)s=n[a],t.indexOf(s)>=0||Object.prototype.propertyIsEnumerable.call(e,s)&&(o[s]=e[s])}return o}var l=a.createContext({}),u=function(e){var t=a.useContext(l),s=t;return e&&(s="function"==typeof e?e(t):r(r({},t),e)),s},m=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var s=e.components,o=e.mdxType,n=e.originalType,l=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),c=u(s),h=o,d=c["".concat(l,".").concat(h)]||c[h]||p[h]||n;return s?a.createElement(d,r(r({ref:t},m),{},{components:s})):a.createElement(d,r({ref:t},m))}));function h(e,t){var s=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var n=s.length,r=new Array(n);r[0]=c;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,r[1]=i;for(var u=2;u<n;u++)r[u]=s[u];return a.createElement.apply(null,r)}return a.createElement.apply(null,s)}c.displayName="MDXCreateElement"},3333:function(e,t,s){s.r(t),s.d(t,{assets:function(){return p},contentTitle:function(){return u},default:function(){return f},frontMatter:function(){return l},metadata:function(){return m},toc:function(){return c}});var a,o=s(3117),n=s(102),r=(s(7294),s(3905)),i=["components"],l={id:"persistent-volumes",title:"Persistent Volumes"},u=void 0,m={unversionedId:"kubernetes/stateful-sets/persistent-volumes",id:"kubernetes/stateful-sets/persistent-volumes",title:"Persistent Volumes",description:"Related Videos",source:"@site/docs/kubernetes/80-stateful-sets/10-persistent-volumes.md",sourceDirName:"kubernetes/80-stateful-sets",slug:"/kubernetes/stateful-sets/persistent-volumes",permalink:"/kubernetes/stateful-sets/persistent-volumes",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{id:"persistent-volumes",title:"Persistent Volumes"},sidebar:"docs",previous:{title:"CronJobs",permalink:"/kubernetes/jobs/cron-jobs"},next:{title:"Persistent Volumes Excercise",permalink:"/kubernetes/stateful-sets/persistent-volumes-exercise"}},p={},c=[{value:"Related Videos",id:"related-videos",level:2},{value:"Volumes",id:"volumes",level:2},{value:"Volume Mounts",id:"volume-mounts",level:3},{value:"Docker Volumes vs. Kubernetes Volumes",id:"docker-volumes-vs-kubernetes-volumes",level:3},{value:"Persistent Volumes (PV)",id:"persistent-volumes-pv",level:2},{value:"Persistent Volume",id:"persistent-volume",level:3},{value:"Persistent Volume Claim (PCV)",id:"persistent-volume-claim-pcv",level:3},{value:"Storage Class",id:"storage-class",level:3},{value:"Storage Provisioner",id:"storage-provisioner",level:3},{value:"Manual Provisioning",id:"manual-provisioning",level:3},{value:"Links",id:"links",level:2}],h=(a="VideoContainer",function(e){return console.warn("Component "+a+" was not imported, exported, or provided by MDXProvider as global scope"),(0,r.kt)("div",e)}),d={toc:c};function f(e){var t=e.components,s=(0,n.Z)(e,i);return(0,r.kt)("wrapper",(0,o.Z)({},d,s,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"related-videos"},"Related Videos"),(0,r.kt)(h,{list:[{src:"https://www.youtube-nocookie.com/embed/yKHC8Mhzra4",title:"Persistent Volumes Part 1"},{src:"https://www.youtube-nocookie.com/embed/83RfSH0CrrI",title:"Persistent Volumes Part 2"}],mdxType:"VideoContainer"}),(0,r.kt)("hr",null),(0,r.kt)("p",null,"This lesson covers the theoretical background necessary to understand the Persistent Volume concept in Kubernetes."),(0,r.kt)("p",null,"Persistent Volumes are introduced in this chapter, although they can also be used with familiar Kubernetes resources such as Pods and ReplicaSets and - although many Kubernetes users do that applications should be kept as stateless as possible. Therefore, note that state should be managed by stateful data services as proposed in the 12 factor manifest ","[14]","."),(0,r.kt)("h2",{id:"volumes"},"Volumes"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Volumes bring persistency to containers"),". Containers are stateless in so far as changes to their filesystem will be lost if a container is restarted - more precisely rescheduled. Rescheduling means that the container is destroyed, but a new container of the same kind is started somewhere in the cluster. This freshly created container will be derived from the given container image and hence won't reflect any changes made in prior existing containers."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Volumes allow sharing information among containers"),". At least some types of Volumes allow sharing of information among containers. A NFS Volume, for example, can be used to share assets such as photos uploaded by application users and store them on a shared filesystem. Be aware that this is an antipattern for cloud native applications which will store assets in an object store such as OpenStack Swift ","[3]",", Amazon S3 ","[4]"," or the alike. Object stores scale horizontally for both load and capacity. In addition to that their availability and durability is usually higher than those of shared filesystems. However, for some legacy applications this may be a valid choice."),(0,r.kt)("p",null,"More than that, Volumes are used in conjunction with concepts such as ConfigMaps and Secrets as shown in earlier lessons. Both ConfigMaps and Secrets can be either consumed as environment variables or be mounted as files. The latter option uses the concept of Kubernetes Volumes."),(0,r.kt)("h3",{id:"volume-mounts"},"Volume Mounts"),(0,r.kt)("p",null,"Within a Pod-definition volumes can be mounted to containers by using a so-called ",(0,r.kt)("strong",{parentName:"p"},"volume mount"),". You are already familiar with the syntax as volume mounts have been used in the ConfigMap and Secrets lessons using the ",(0,r.kt)("inlineCode",{parentName:"p"},"volumeMounts")," field in container specs."),(0,r.kt)("h3",{id:"docker-volumes-vs-kubernetes-volumes"},"Docker Volumes vs. Kubernetes Volumes"),(0,r.kt)("p",null,"If you are familiar with Docker Volumes you may already recognize the difference between Kubernetes and Docker Volumes. In Kubernetes there are many more types of Volumes and the way to use them is more flexible. For example, in Kubernetes it is possible to mount multiple containers of multiple types into a single container. Additionally, the lifecycle of Volumes is clearly defined in Kubernetes. Volumes share the lifecycle of their Pods. They are created with their Pods and cease to exist when their Pods cease to exist. You will see that there are concepts such as the ",(0,r.kt)("em",{parentName:"p"},"Persistent Volume")," with lifetimes exceeding the lifetime of their Pods."),(0,r.kt)("h2",{id:"persistent-volumes-pv"},"Persistent Volumes (PV)"),(0,r.kt)("p",null,"It may appear intuitive that Persistent Volumes (PV) are special types of Volumes but in fact there are two distinct Kubernetes resources."),(0,r.kt)("p",null,"As mentioned before, the ",(0,r.kt)("strong",{parentName:"p"},"major difference of Volumes and Persistent Volumes is their lifetime"),". Volumes exist as long as their corresponding Pods while ",(0,r.kt)("strong",{parentName:"p"},"Persistent Disks")," potentially survive Pods and may ",(0,r.kt)("strong",{parentName:"p"},"live as long as the Kubernetes cluster lives"),"."),(0,r.kt)("p",null,"Persistent Volumes are not storage implementation but rather a storage abstraction. The Persistent Volume subsystem comprises resource types for creating and attaching volumes. In order to use Persistent Volumes you need to be familiar with the following concepts:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Persistent Volume (PV)"),(0,r.kt)("li",{parentName:"ul"},"Persistent Volume Claim (PVC)"),(0,r.kt)("li",{parentName:"ul"},"Storage Class"),(0,r.kt)("li",{parentName:"ul"},"Storage Provisioner")),(0,r.kt)("h3",{id:"persistent-volume"},"Persistent Volume"),(0,r.kt)("p",null,"The Persistent Volume is what the name suggests: the actual volume where data is being stored. What exactly a Persistent Volume is, is up to its implementation. Often, a PV may be represented by a remotely attached block device such as an Amazon Block Store (AWS EBS) volume ","[5]","."),(0,r.kt)("p",null,"The Persistent Volume concept implies two important questions:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"How are Persistent Volumes created?"),(0,r.kt)("li",{parentName:"ol"},"Where and when are Persistent Volumes associated and mounted to containers?")),(0,r.kt)("h3",{id:"persistent-volume-claim-pcv"},"Persistent Volume Claim (PCV)"),(0,r.kt)("p",null,"Similar to Volumes, Persistent Volumes ","[2]"," are also mounted using the ",(0,r.kt)("inlineCode",{parentName:"p"},"volumeMount"),' field in the specification of a container. The volume mount basically says "mount the persistent volume ',(0,r.kt)("inlineCode",{parentName:"p"},"x")," to the path ",(0,r.kt)("inlineCode",{parentName:"p"},"y")," of my container ",(0,r.kt)("inlineCode",{parentName:"p"},"z"),". But ",(0,r.kt)("strong",{parentName:"p"},"before a volume mount can happen, the Persistent Volume must be requested using a Persistent Volume Claim"),'. Think of storage as "territory" and a Persistent Volume Claim as a claim to a particular part of that "territory" or storage. Hence, ',(0,r.kt)("strong",{parentName:"p"},"a Persistent Volume Claim is a declarative description of a piece of storage requested by the user"),". In this sense, a PVC may sound like"),(0,r.kt)("p",null,"Give me:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},'"3 gigabytes of fast SSD storage"')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},'"500 gigabytes of cheap hard disk drive storage. You know the old rotating magnetic drives."')),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("em",{parentName:"li"},'"50 gigabytes of very reliable SSD storage"'))),(0,r.kt)("p",null,"As you can see these requests may include different ",(0,r.kt)("strong",{parentName:"p"},"quantities")," and ",(0,r.kt)("strong",{parentName:"p"},"qualities")," of storage. While quantities are measures in bytes, qualities can be anything from ",(0,r.kt)("em",{parentName:"p"},"availability"),", ",(0,r.kt)("em",{parentName:"p"},"durability")," to ",(0,r.kt)("em",{parentName:"p"},"speed"),"."),(0,r.kt)("h3",{id:"storage-class"},"Storage Class"),(0,r.kt)("p",null,"Storage Classes ","[13]"," are there to reflect the above-mentioned qualities such as ",(0,r.kt)("em",{parentName:"p"},"availability"),", ",(0,r.kt)("em",{parentName:"p"},"durability"),", ",(0,r.kt)("em",{parentName:"p"},"speed"),", ",(0,r.kt)("em",{parentName:"p"},"backup policies")," etc."),(0,r.kt)("p",null,"This leads to the question of where the difference of Persistent Volumes by Storage Class is actually manifested. Simply speaking, a Storage Class represents a configuration that is passed into a so-called ",(0,r.kt)("em",{parentName:"p"},"Storage Provisioner"),"."),(0,r.kt)("h3",{id:"storage-provisioner"},"Storage Provisioner"),(0,r.kt)("p",null,"The Storage Provisioner is where Persistent Volumes of a particular Storage Classes are actually created."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"A Storage Provisioner is responsible for dynamically creating storage volumes corresponding to Persistent Volume Claims requested by users"),"."),(0,r.kt)("p",null,"The underlying storage system can be anything from a software defined storage (SDS)","[6]"," such as ceph ","[7]",", gluster ","[8]",", etc. to hardware appliances accessed directly or through the API of an infrastructure provider such as AWS ","[9]",", Azure ","[10]",", GCP ","[11]"," or AliCloud ","[12]",". Each of these systems - along with many other storage solutions - have to be addressed in a particular way. This is the main subject of a Storage Provisioner implementation."),(0,r.kt)("h3",{id:"manual-provisioning"},"Manual Provisioning"),(0,r.kt)("p",null,"The documentation ","[2]"," also mentions manual provisioning. In this case Persistent Volumes are pre-created by the cluster administrator. Applications then use Persistent Volume Claims to request a Persistent Volume from the pool of PVs. While this use case may make sense in legacy use cases, such a Stone Age methodology should be avoided whenever possible. The absence of dynamic volume provisioning is likely to block the workflow of application developers during deployment when Persistent Volume Claims can't be fulfilled as the cluster ran out of Persistent Volumes."),(0,r.kt)("h2",{id:"links"},"Links"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Kubernetes Documentation, Concepts, Storage, Volumes, ",(0,r.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/concepts/storage/volumes/"},"https://kubernetes.io/docs/concepts/storage/volumes/")),(0,r.kt)("li",{parentName:"ol"},"Kubernetes Documentation, Concepts, Storage, Persistent Volumes, ",(0,r.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/concepts/storage/persistent-volumes/"},"https://kubernetes.io/docs/concepts/storage/persistent-volumes/")),(0,r.kt)("li",{parentName:"ol"},"OpenStack Swift, ",(0,r.kt)("a",{parentName:"li",href:"https://github.com/openstack/swift"},"https://github.com/openstack/swift")),(0,r.kt)("li",{parentName:"ol"},"Amazon S3, ",(0,r.kt)("a",{parentName:"li",href:"https://aws.amazon.com/s3/"},"https://aws.amazon.com/s3/")),(0,r.kt)("li",{parentName:"ol"},"Amazon EBS, ",(0,r.kt)("a",{parentName:"li",href:"https://aws.amazon.com/ebs/"},"https://aws.amazon.com/ebs/")),(0,r.kt)("li",{parentName:"ol"},"Wikipedia, Software Defined Storage, ",(0,r.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Software-defined_storage"},"https://en.wikipedia.org/wiki/Software-defined_storage")),(0,r.kt)("li",{parentName:"ol"},"Ceph, ",(0,r.kt)("a",{parentName:"li",href:"https://ceph.io/"},"https://ceph.io/")),(0,r.kt)("li",{parentName:"ol"},"gluster, ",(0,r.kt)("a",{parentName:"li",href:"https://www.gluster.org/"},"https://www.gluster.org/")),(0,r.kt)("li",{parentName:"ol"},"Amazon Web Services, ",(0,r.kt)("a",{parentName:"li",href:"http://aws.amazon.com/"},"http://aws.amazon.com/")),(0,r.kt)("li",{parentName:"ol"},"Microsoft Azure, ",(0,r.kt)("a",{parentName:"li",href:"https://azure.microsoft.com"},"https://azure.microsoft.com")),(0,r.kt)("li",{parentName:"ol"},"Google Cloud Platform, ",(0,r.kt)("a",{parentName:"li",href:"https://cloud.google.com/"},"https://cloud.google.com/")),(0,r.kt)("li",{parentName:"ol"},"Alibaba Cloud, ",(0,r.kt)("a",{parentName:"li",href:"https://eu.alibabacloud.com/"},"https://eu.alibabacloud.com/")),(0,r.kt)("li",{parentName:"ol"},"Kubernetes documentation, Concepts, Storage Classes, ",(0,r.kt)("a",{parentName:"li",href:"https://kubernetes.io/docs/concepts/storage/storage-classes/"},"https://kubernetes.io/docs/concepts/storage/storage-classes/")),(0,r.kt)("li",{parentName:"ol"},"The Twelve Factor App, ",(0,r.kt)("a",{parentName:"li",href:"https://12factor.net/"},"https://12factor.net/"))))}f.isMDXComponent=!0}}]);